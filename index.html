<!DOCTYPE html>
<html>
<head>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

	<meta charset="UTF-8">
	<title>Arthur Wu</title>
	<link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap" rel="stylesheet">
	<style>
		body {
			display: flex;
			flex-direction: column;
			justify-content: flex-start;
			align-items: center;
			height: 100vh;
			margin: 0;
			padding-top: 10%;
			background-color: #e0f7fa;
			font-family: 'Roboto', sans-serif;
			overflow: hidden;
		}
		.title {
			color: #3a3a3a;
			font-size: 2.5em;
			font-weight: 700;
			margin-bottom: 0.5em;
		}
		.subtitle {
			color: #333;
			font-size: 1.5em;
			font-weight: 400;
			margin-bottom: 1em;
		}
		canvas {
			position: fixed;
			top: 0;
			left: 0;
			z-index: 1; /* Above the default background, but below the content */
		}
		.content {
			position: relative;
			z-index: 2; /* Above the Three.js canvas */
		}
		a {
    color: #333;
    font-size: 1.2em;
    text-decoration: none;
    margin: 1em;  /* Increased margin for separation */
    padding: 0.5em 1em;
    border-radius: 3em;
    border: 2px solid #333;
    transition: all 0.3s ease-in-out, transform 0.3s ease-in-out, box-shadow 0.3s ease-in-out; 
    box-shadow: 0px 2px 5px rgba(0, 0, 0, 0.1);  /* initial box-shadow for a raised button effect */
    display: inline-block;  /* Allows transform to work as expected */
}

a:hover {
    background-color: #333;
    color: #e0f7fa;
    transform: scale(1.5); /* enlarge the button slightly */
    box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.2); /* enhance box-shadow for a more pronounced raised effect */
}

		.projects-link {
			color: #333;
			font-weight: 400;
			margin-top: 1em;
			font-size: 1.2em;
		}
	</style>
</head>
<body>
	<div class="content">
	<p class="title">Arthur Wu</p>
	<br>
	<p class="subtitle">Computer Science + Data Analytics + Finance @ the University of Virginia</p>
	<br>
	<br>
	<a href="https://www.linkedin.com/in/arthur-wu-kn/">LinkedIn</a>
	<a href="https://github.com/arthurwu1227">Github</a>
	<a href="projects.html" class="projects-link">Portfolio</a>
</div>
	<script>
    let scene, camera, renderer;
const cubes = [];
const cubeSizes = [];
const cubePositions = [];

function isOverlapping(x, y, z, size) {
    for (let i = 0; i < cubePositions.length; i++) {
        const dx = x - cubePositions[i].x;
        const dy = y - cubePositions[i].y;
        const dz = z - cubePositions[i].z;

        const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
        if (distance < size + cubeSizes[i]) {
            return true;
        }
    }
    return false;
}

function init() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const MAX_CUBE_SIZE = 7; // Maximum cube size
    const MAX_POSITION = 40; // Maximum absolute position for x, y, and z
    for (let i = 0; i < 10; i++) {
        const size = Math.min(MAX_CUBE_SIZE, 5 + Math.random() * 10);
        const geometry = new THREE.BoxGeometry(size, size, size);
        const material = new THREE.MeshBasicMaterial({ color: Math.random() * 0xffffff, opacity: 0.6, transparent: true });
        const cube = new THREE.Mesh(geometry, material);

        let xPos, yPos, zPos;
    do {
        xPos = (Math.random() - 0.5) * 2 * MAX_POSITION;
        yPos = (Math.random() - 0.5) * 2 * MAX_POSITION;
        zPos = (Math.random() - 0.5) * 2 * MAX_POSITION;
    } while (isOverlapping(xPos, yPos, zPos, size) ||
             Math.abs(xPos) + size > MAX_POSITION ||
             Math.abs(yPos) + size > MAX_POSITION ||
             Math.abs(zPos) + size > MAX_POSITION);
        cubePositions.push({ x: xPos, y: yPos, z: zPos });
        cubeSizes.push(size);

        cube.position.set(xPos, yPos, zPos);
        cube.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
        cubes.push(cube);
        scene.add(cube);
    }

    camera.position.z = 50;

    window.addEventListener('resize', onWindowResize, false);
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
    requestAnimationFrame(animate);

    cubes.forEach(cube => {
        cube.rotation.x += 0.005;
        cube.rotation.y += 0.005;
    });

    renderer.render(scene, camera);
}

init();
animate();

</script>

</body>
</html>
